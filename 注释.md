# RBAC：用户角色权限控制
# 通过给用户分配不同的角色，再给角色分配不同的菜单权限，进而实现给用户分配不同的菜单权限;
# 实现RBAC，至少涉及到5张表：
# 用户表user_info：存放用户信息 userId userName ..

# 角色表role :存放角色信息 roleId roleName...
# 用户角色中间表user_role:存放用户角色关系，而且用户与角色是多对多关系， userId  roleId
# 菜单权限表auth_info:存放菜单信息 id pid authName

# 角色菜单权限中间表role_auth 存放的是角色菜单关系，体现了给用户分配的菜单权限，而且角色和菜单是多对多关系 role menuId

# 根据用户id从3表查询出角色id，再从5表查询出角色对应的菜单


## 登录业务
# 查询用户权限菜单树
/user/auth-list:
加载用户权限菜单树的方式:
1.后台系统中查询出用户权限下的所有菜单:一个List<Auth>,然后将用户所有的菜单的List<Auth>响应给前端
给前端，前端有添加权限菜单树的组件，根据表中的auth_id与parent_id,来展现表中的层级关系，通过每个菜单之间的id与pid生成菜单树
菜单树---前端生成
2.同样是后台查询出用户权限下的所有菜单，然后将用户所有菜单的List转成菜单树List<Auth>,最后将菜单树List响应给前端，前端循环迭代，展示即可
---菜单树后端生成，前端仅仅是做了个展示迭代



## 用户管理模块:
# 1.用户列表
# 根据url，如果userCode userType userState没有值，是查询所有用户并且分页，如果有值，则根据账号
# 用户状态 用户类型分页查询用户并且分页
# 如何接收参数:参数使用user对象，进行接收并且封装，参数与page相关的使用Page对象接收并且封装
# 响应数据问题:给前端响应封装了所有分页信息的Page对象

# 2.添加用户

# 关于判断，在表单上其实已经给了判断
# 3.启用和禁用用户
# 对某个数据的某项做修改

# 4.给用户分配角色
#  第一个接口:分配角色也有修改角色的功能:如果是修改角色，需要回显用户已分配角色
# 第二个接口:此外需要查询所有角色，展示所有角色在下拉框(在这如果开启redis注解缓存，会出现问题)
# 第三个接口:给用户分配角色权，前端与后端交互数据过多，就存在组装问题，故如果是前端传给后端定义dto对象，
# 后端传给前端则采用vue对象


# 5.删除用户
# 拿到用户ID，根据用户ID删除或者删除一堆用户，是给List集合的json串，根据ids批量删除
# 根据数据库，实际上是修改语句，修改从1变成0，将业务实现到一个接口
# 删除一个用户，不仅仅要仅仅是删除，还有对于在user_role给用户分配的角色也要删除，不过也没有关系，只要是删除掉用户，在用户列表里也就不会展示出用户信息，那么也就改不了角色分配，其实也不需要在一删除用户的同时删除user_role里对应用户的角色信息
# 问题就是会导致 user_role的表中数据会很多


# 6.修改用户
# 即根据用户id修改用户昵称
# 7.重置密码
# 即还原密码到初始状态(假设为123456)，注意是还原为加密密码



-------------------------------------------------------------

# 角色管理模块
# 1.角色列表
# 查询所有的角色并分页
# 根据角色名称 角色代码 角色状态查询
# 2.添加用户
# 将输入的角色信息后传给后端，SQL录入，同时需要考虑角色是否同名:名称、代码都需要考虑不同
# 3.启用和禁用角色
# 启用和禁用角色，只需要roleId和roleState
# 4.给角色分配权限
# /role/role-auth?roleId=----根据roleId查询角色的已分配的所有权限
# /auth/auth-tree  --查询所有的权限菜单树(也就是把所有的列表名都给你展示出来，然后到时候分配权限用)
# 5.删除角色
# 根据角色id去删除角色，因为角色与角色权限关联着，删除用户，不删除权限里对应的角色关系也没关系，但并不是修改状态，而是直接删
# 6.修改角色
# /role/role-update 根据id修改描述和角色名称



-----------------------------------------------------------------
# 3.商品管理
# 1.商品列表
  ##  1>.分页查询商品
/product-store-list---查询所有仓库--下拉框
/product-brand-list---查询所有品牌---下拉框
当所有的url参数都没值，则是查询所有的仓库所有商品信息
仓库 商品名称 品牌 类型 供应商 产地 上下架状态 过期与否查询商品并分页
请求参数处理:
用product对象做接收并且封装

商品列表展示的信息:
仓库名storeName---追加属性
单位unitName---追加属性


 ## 2>. 添加商品
/product-category-tree---查询所有分类树----给添加商品用
/product-supply-list----查询所有供应商----给添加商品提供
/product-place-list--查询所有产地--给添加商品提供
/product/unit-list--查询所有单位---给添加商品提供
/product/image/upload上传图片 file:上传图片的字节数据
/product/product-add 添加商品
## 3>. 修改商品上下架状态
点击操作链接/product/state-change
上架:upDownState=0/1
## 4>. 删除商品
单个删除:/product/product-delete/对应的删除id
批量删除:/product/product-list/delete
将两个接口尝试走一个业务
## 5>. 修改商品
数据的回显，不是后端的结果，是vue的数据绑定
/product/product-update
其中，如果图片没有被修改，则还是完整的访问地址，如果被修改了，则只有图片名称，因此需要做判断
其中;创建人，创建时间，上下架状态不能够修改,型号需要判断下是否有重复，而如果不动型号，则判断时，查询型号则会存在
方法：根据型号查询商品，对比商品id
若查询发现型号相同，id不同，则说明是在修改型号，但已经存在该型号，说明这个型号不能设置，而如果型号相同，id相同，说明型号就没改，
## 6>.  添加采购单
/purchase/purchase-add
采购流程:
1).在商品列表针对具体商品，添加采购单----buy_list(此时是状态为0未入库)--预买
2).当商品采购到之后，入库，---在采购单列表做入库操作 ---向入库单表in_store添加记录(此时状态为0未入库)同时修改采购单表buy_list表，由
0到1入库---准备入库
3).商品真正入库----在入库单，做确认入库操作----将入库单in_store表的入库单状态由0改为1入库
下采购单:是计划要搞多少放进仓库，但从工厂生产等等方面，可能实际达不到计划的数量，因此实际采购数量，初始为空，故在修改采购单(一些场外因素，比如联系工厂啊等等)才确认要采购这么多货进仓库
## 7>.  添加出库单
/outstore/outstore-add
出库流程:
1).在商品列表针对具体的商品，添加出库单----向出库单表out_store表添加出库单信息(状态是0未出库)--准备出库
2).商品真正出库之后，在出库单列表做确认出库操作--将出库单表out_store表的出库状态由0变为1已出库 


# 2.商品分类:
## 1>.商品分类树查询
已经在添加商品，给商品指定活动分类时写过具体的sql操作实现，但接口这里不一样,是一个独有的商品分类树,因此在service层调用的时候
可以用来调用，只是controller返回的接口不一样
/productCategory/product-category-tree  ---定义新的url接口，调用添加商品时编写的查询商品分类的业务

## 2>.添加商品分类
添加子集分类:选择父级分类，点击添加分类，然后添加子集分类
添加父级分类：什么都不用选择，直接点击添加分类即可
分类编码不能重复且分类名也不能重复
/productCategory/verify-type-code---用来校验分类编码是否存在
验证分类编码，是在输入数据的时候，根据url校验
验证分类名称，是在提交表单之后验证,
其逻辑为:当在表单时，一旦输入数据，立马触发url逻辑，对分类编码在后端进行判断，判断其是否已存在
从而，只要在模态框一输入一个相同的分类编码，就立刻反应，
/product/type-add，是添加商品的触发url

## 3>.删除
/type-delete/{typeId}--删除商品分类----根据分类，如果是最子集分类，删除子集分类，如果是父级分类，点击删除，删除全部分类
因此不能只根据传来的分类id删除分类，还应该将传来的分类id看成parentId，来删除所有子分类(不过一般来说，就两层就足够了)
## 4>.修改
只能改变分类名称与分类描述，修改分类名称仍然需要判断下分类描述是否


-------------------------------------------------------
# 采购管理
# 1.采购列表
/purchase/store-list----查询仓库---查询条件需要(已写)
根据仓库id 起止时间 商品名称 采购员 是否入库等查询采购单并且分页

请求参数分析：
pageNum pageSize 用Page对象去作封装
storeId startTime endTime productName buyUser isIn,用purchase对象接收并且封装，但是Purchase没有startTime与endTime，produceTime属性，因此需要追加

采购单列表展示数据:
额外需要 仓库名 商品名 ----给purchase追加属性 storeName ProductName;

# 2.删除采购单
修改与删除按钮是否出现，取决于是否生成采购数量
/purchase/purchase-delete/{buyId}----根据id删除采购单

# 3.修改采购单
/purchase/update

# 4.生成入库单
实际上是当商品采购到之后，要将其入库，入库就要生成入库单,不仅仅要向入库单生成入库记录，同时还要修改入库状态
故需要操作两张表:1.向入库单添加采购信息
       2.修改采购单表中入库状态

/purchase/in_warehouse-record-add


--------------------------------------------------------------
## 入库管理
# 1.分页查询入库列表
/instore/store-list---查询所有仓库
/instore/instore-page-list   --查询所有入库单并分页或者根据仓库id、商品名称、截止时间，查询入库单
请求参数：
入库单列表展示的信息分析:
页码 pageNum 每页行数: pageSize ----Page接收并封装
storeId productName startTime endTime --InStore对象接收并封装---InStore需要追加属性
productName startTime endTime storeName inPrice userCode
需要联查 入库单表 入库表 商品表 仓库表
# 2.确认入库
即商品真正入库，此时将入库单的状态由0变成1且此时真正入库，商品的库存也增加
/instore/instore-confirm
---------------------------------------------------------------------
出库单管理模块
# 1.出库列表
/outstore-list----查询所有仓库:用来做添加下拉框用
/outstore-page-list-----分页查询出库单
请求参数:pageNum pageSize----page对象接收并封装
storeId productName startTime endTime isOut----这些数据，由outStore对象接收并且封装
对于没有的属性，同样需要追加

展示的数据:仓库名称、商品名称，创建人，这些需要用到追加属性
因此需要用到多表联查，其中需要查询的数据表有:out_store,product,user_info,store
# 2.确认出库
出库流程里面的第二步
# 在商品里面点击出库仅仅是进入出库单，而在出库单里点击确认出库才是正式出库
1).根据id修改仓库库存已写，而在确认出库这里，主要是将传入的值变成负数
/outstore-comfirm
2).因此在这里，只需要写更改出库状态



mapper语句里面的#{里面的值和mapper传参的变量名一样}



# 统计查询
该页面由echart构成，其用来提供很多图形的框架
将后台提供的数据，根据Echarts模板提供的样例代码，后台数据响应给前端，前端数据填充进样例模板，即可实现各种如柱状图、饼状图等效果
库存信息:/statistics/store-invent 用来展示仓库的当前库存信息
其中仓库名中没有仓库容量，该数据在商品表，故两表联查

如何将查询的数据组装起来响应给前端:创建一个工具包一个工具类进行操作,vo包里面创建的工具类，其实没有明确的mapper，因此找个合适的放进去就好
由于这个url是/statstic打头，对于仓库的统计等等，其实并不是定向到以前/store的路由上：毕竟是新的页面的功能实现上，因此前缀路由不一样 
因此需要一个新的控制器controller



# 仓库管理模块
# 1.查询仓库
这里的仓库管理在查询仓库时，不是点击出现下拉框的类型（毕竟这里是仓库管理模块，是对仓库为主体的管理，因此是输入内容进行查询）
首先，要查询的信息，全都是在数据库的store表中的，因此不需要设计到多表查询
在查询条件里面，包含仓库名称、仓库地址、联系人、电话这些条件，因此如果要将这个与全查写成一个整体的查询语句，需要用到if判断，做动态查询
从而实现不仅仅能够全查循，也可以根据条件进行查询与计算不同条件下的分页情况

# 2.添加仓库
在这里，添加仓库的信息与数据库表中要添加的项一致，因此可以直接采用mybatis-plus进行添加
当然会有一个判断，即要求仓库编码与仓库名称不能相同，
验证仓库编码，是在输入数据的时候，根据url校验
验证仓库名称，是在提交表单之后验证,
其逻辑为:当在表单时，一旦输入数据，立马触发url逻辑，对仓库编码在后端进行判断，判断其是否已存在
从而，只要在模态框一输入一个相同的分类编码，就立刻反应，



为什么没有给名称设置鼠标事件，而在这些添加里面给编号设置事件:
不好说~这个东西就有点像，为什么我在注册账户时，输入昵称如果不存在会先有触发事件一样。
首先，这个添加一定是在这个列表里添加，姓名，作为表面展示的东西，人为可以规避错误，而编号做为内部信息，不展示在管理系统里面，当用户添加新数据时，很容易输错，因此单独拿出业务做判断

# 3.修改仓库
修改仓库只能够修改的数据有：名称、地址、联系人、电话
在修改仓库名称的时候，需要保证仓库的名称与当前数据库中的名称不冲突

# 4.导出数据:
/store/exportTable
所有的导出数据：都是exportTable，因此直接
